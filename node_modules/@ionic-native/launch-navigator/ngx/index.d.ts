import { IonicNativePlugin } from '@ionic-native/core';
import * as ɵngcc0 from '@angular/core';
export interface PromptsOptions {
    /**
     * a function to pass the user's decision whether to remember their choice of app.
     * This will be passed a single boolean value indicating the user's decision.
     * @param rememberChoice
     */
    callback?: (rememberChoice: boolean) => void;
    /**
     * text to display in the native prompt header asking user whether to remember their choice.
     * Defaults to "Remember your choice?" if not specified.
     */
    headerText?: string;
    /**
     * text to display in the native prompt body asking user whether to remember their choice.
     * Defaults to "Use the same app for navigating next time?" if not specified.
     */
    bodyText?: string;
    /**
     * text to display for the Yes button.
     * Defaults to "Yes" if not specified.
     */
    yesButtonText?: string;
    /**
     * text to display for the No button.
     * Defaults to "No" if not specified.
     */
    noButtonText?: string;
}
export interface RememberChoiceOptions {
    /**
     * whether to remember user choice of app for next time, instead of asking again for user choice.
     * `"prompt"` - Prompt user to decide whether to remember choice.
     *  - Default value if unspecified.
     *  - If `promptFn` is defined, this will be used for user confirmation.
     *  - Otherwise (by default), a native dialog will be displayed to ask user.
     * `false` - Do not remember user choice.
     * `true` - Remember user choice.
     */
    enabled?: boolean | string;
    /**
     * a function which asks the user whether to remember their choice of app.
     * If this is defined, then the default dialog prompt will not be shown, allowing for a custom UI for asking the user.
     * This will be passed a callback function which should be invoked with a single boolean argument which indicates the user's decision to remember their choice.
     * @param callback
     */
    promptFn?: (callback: (rememberChoice: boolean) => void) => void;
    /**
     * options related to the default dialog prompt used to ask the user whether to remember their choice of app.
     */
    prompt?: PromptsOptions;
}
export interface AppSelectionOptions {
    /**
     * text to display in the native picker which enables user to select which navigation app to launch.
     * Defaults to "Select app for navigation" if not specified.
     */
    dialogHeaderText?: string;
    /**
     * text to display for the cancel button in the native picker which enables user to select which navigation app to launch.
     * Defaults to "Cancel" if not specified.
     */
    cancelButtonText?: string;
    /**
     * List of apps, defined as `launchnavigator.APP` constants, which should be displayed in the picker if the app is available.
     * This can be used to restrict which apps are displayed, even if they are installed.
     * By default, all available apps will be displayed.
     */
    list?: string[];
    /**
     * Callback to invoke when the user selects an app in the native picker.
     * A single string argument is passed which is the app what was selected defined as a `launchnavigator.APP` constant.
     */
    callback?: (app: string) => void;
    /**
     * (Android only) native picker theme. Specify using `actionsheet.ANDROID_THEMES` constants.
     * Default `actionsheet.ANDROID_THEMES.THEME_HOLO_LIGHT`
     */
    androidTheme?: number;
    /**
     * options related to whether to remember user choice of app for next time, instead of asking again for user choice.
     */
    rememberChoice?: RememberChoiceOptions;
}
export interface LaunchNavigatorOptions {
    /**
     * A callback to invoke when the navigation app is successfully launched.
     */
    successCallback?: Function;
    /**
     * A callback to invoke if an error is encountered while launching the app.
     * A single string argument containing the error message will be passed in.
     */
    errorCallback?: (error: string) => void;
    /**
     * name of the navigation app to use for directions.
     * Specify using launchnavigator.APP constants.
     * e.g. `launchnavigator.APP.GOOGLE_MAPS`.
     * If not specified, defaults to User Selection.
     */
    app?: string;
    /**
     * nickname to display in app for destination. e.g. "Bob's House".
     */
    destinationName?: string;
    /**
     * Start point of the navigation.
     * If not specified, the current device location will be used.
     * Either:
     *  - a {string} containing the address. e.g. "Buckingham Palace, London"
     *  - a {string} containing a latitude/longitude coordinate. e.g. "50.1. -4.0"
     *  - an {array}, where the first element is the latitude and the second element is a longitude, as decimal numbers. e.g. [50.1, -4.0]
     */
    start?: string | number[];
    /**
     * nickname to display in app for start . e.g. "My House".
     */
    startName?: string;
    /**
     * Transportation mode for navigation: "driving", "walking" or "transit". Defaults to "driving" if not specified.
     */
    transportMode?: string;
    /**
     * If true, debug log output will be generated by the plugin. Defaults to false.
     */
    enableDebug?: boolean;
    /**
     * a key/value map of extra app-specific parameters. For example, to tell Google Maps on Android to display Satellite view in "maps" launch mode: `{"t": "k"}`
     */
    extras?: any;
    /**
     * (Android only) mode in which to open Google Maps app.
     * `launchnavigator.LAUNCH_MODE.MAPS` or `launchnavigator.LAUNCH_MODE.TURN_BY_TURN`
     * Defaults to `launchnavigator.LAUNCH_MODE.MAPS` if not specified.
     */
    launchModeGoogleMaps?: string;
    /**
     * (iOS only) method to use to open Apple Maps app.
     * `launchnavigator.LAUNCH_MODE.URI_SCHEME` or `launchnavigator.LAUNCH_MODE.MAPKIT`
     * Defaults to `launchnavigator.LAUNCH_MODE.URI_SCHEME` if not specified.
     */
    launchModeAppleMaps?: string;
    /**
     * If true, and input location type(s) doesn't match those required by the app, use geocoding to obtain the address/coords as required. Defaults to true.
     */
    enableGeolocation?: boolean;
    /**
     * options related to the default native actionsheet picker which enables user to select which navigation app to launch if `app` is not specified.
     */
    appSelection?: AppSelectionOptions;
}
export interface UserChoice {
    /**
     * Indicates whether a user choice exists for a preferred navigator app.
     * @param callback - function to pass result to: will receive a boolean argument.
     */
    exists: (callback: (exists: boolean) => void) => void;
    /**
     * Returns current user choice of preferred navigator app.
     * @param callback - function to pass result to: will receive a string argument indicating the app, which is a constant in `launchnavigator.APP`.
     */
    get: (callback: (app: string) => void) => void;
    /**
     * Sets the current user choice of preferred navigator app.
     * @param app - app to set as preferred choice as a constant in `launchnavigator.APP`.
     * @param callback - function to call once operation is complete.
     */
    set: (app: string, callback: () => void) => void;
    /**
     * Clears the current user choice of preferred navigator app.
     * @param callback - function to call once operation is complete.
     */
    clear: (callback: () => void) => void;
}
export interface UserPrompted {
    /**
     * Indicates whether user has already been prompted whether to remember their choice a preferred navigator app.
     * @param callback - function to pass result to: will receive a boolean argument.
     */
    get: (callback: (exists: boolean) => void) => void;
    /**
     * Sets flag indicating user has already been prompted whether to remember their choice a preferred navigator app.
     * @param callback - function to call once operation is complete.
     */
    set: (callback: () => void) => void;
    /**
     * Clears flag which indicates if user has already been prompted whether to remember their choice a preferred navigator app.
     * @param callback - function to call once operation is complete.
     */
    clear: (callback: () => void) => void;
}
export interface AppSelection {
    userChoice: UserChoice;
    userPrompted: UserPrompted;
}
/**
 * @name Launch Navigator
 * @description
 * Requires Cordova plugin: uk.co.workingedge.phonegap.plugin.launchnavigator. For more info, please see the [LaunchNavigator plugin docs](https://github.com/dpa99c/phonegap-launch-navigator).
 *
 * @usage
 * Please refer to the plugin's repo for detailed usage. This docs page only explains the Native wrapper.
 *
 * ```typescript
 * import { LaunchNavigator, LaunchNavigatorOptions } from '@ionic-native/launch-navigator/ngx';
 *
 * constructor(private launchNavigator: LaunchNavigator) { }
 *
 * ...
 *
 * let options: LaunchNavigatorOptions = {
 *   start: 'London, ON',
 *   app: LaunchNavigator.APPS.UBER
 * }
 *
 * this.launchNavigator.navigate('Toronto, ON', options)
 *   .then(
 *     success => console.log('Launched navigator'),
 *     error => console.log('Error launching navigator', error)
 *   );
 * ```
 * @interfaces
 * LaunchNavigatorOptions
 * PromptsOptions
 * RememberChoiceOptions
 * AppSelectionOptions
 * UserChoice
 * UserPrompted
 * AppSelection
 */
export declare class LaunchNavigator extends IonicNativePlugin {
    APP: any;
    TRANSPORT_MODE: any;
    appSelection: AppSelection;
    /**
     * Launches navigator app
     * @param destination {string|number[]} Location name or coordinates (as string or array)
     * @param options {LaunchNavigatorOptions}
     * @returns {Promise<any>}
     */
    navigate(destination: string | number[], options?: LaunchNavigatorOptions): Promise<any>;
    /**
     * Determines if the given app is installed and available on the current device.
     * @param app {string}
     * @returns {Promise<any>}
     */
    isAppAvailable(app: string): Promise<any>;
    /**
     * Returns a list indicating which apps are installed and available on the current device.
     * @returns {Promise<string[]>}
     */
    availableApps(): Promise<string[]>;
    /**
     * Returns the display name of the specified app.
     * @param app {string}
     * @returns {string}
     */
    getAppDisplayName(app: string): string;
    /**
     * Returns list of supported apps on a given platform.
     * @param platform {string}
     * @returns {string[]}
     */
    getAppsForPlatform(platform: string): string[];
    /**
     * Indicates if an app on a given platform supports specification of transport mode.
     * @param app {string} specified as a string, you can use one of the constants, e.g `LaunchNavigator.APP.GOOGLE_MAPS`
     * @param platform {string}
     * @returns {boolean}
     */
    supportsTransportMode(app: string, platform: string): boolean;
    /**
     * Returns the list of transport modes supported by an app on a given platform.
     * @param app {string}
     * @param platform {string}
     * @returns {string[]}
     */
    getTransportModes(app: string, platform: string): string[];
    /**
     * @param app {string}
     * @param platform {string}
     * @returns {boolean}
     */
    supportsDestName(app: string, platform: string): boolean;
    /**
     * Indicates if an app on a given platform supports specification of start location.
     * @param app {string}
     * @param platform {string}
     * @returns {boolean}
     */
    supportsStart(app: string, platform: string): boolean;
    /**
     * @param app {string}
     * @param platform {string}
     * @returns {boolean}
     */
    supportsStartName(app: string, platform: string): boolean;
    /**
     * Indicates if an app on a given platform supports specification of launch mode.
     * Note that currently only Google Maps on Android does.
     * @param app {string}
     * @param platform {string}
     * @returns {boolean}
     */
    supportsLaunchMode(app: string, platform: string): boolean;
    /**
     * @param destination {string | number[]}
     * @param options {LaunchNavigatorOptions}
     */
    userSelect(destination: string | number[], options: LaunchNavigatorOptions): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<LaunchNavigator, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<LaunchNavigator>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW9uaWNOYXRpdmVQbHVnaW4gfSBmcm9tICdAaW9uaWMtbmF0aXZlL2NvcmUnO1xuZXhwb3J0IGludGVyZmFjZSBQcm9tcHRzT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogYSBmdW5jdGlvbiB0byBwYXNzIHRoZSB1c2VyJ3MgZGVjaXNpb24gd2hldGhlciB0byByZW1lbWJlciB0aGVpciBjaG9pY2Ugb2YgYXBwLlxuICAgICAqIFRoaXMgd2lsbCBiZSBwYXNzZWQgYSBzaW5nbGUgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHRoZSB1c2VyJ3MgZGVjaXNpb24uXG4gICAgICogQHBhcmFtIHJlbWVtYmVyQ2hvaWNlXG4gICAgICovXG4gICAgY2FsbGJhY2s/OiAocmVtZW1iZXJDaG9pY2U6IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogdGV4dCB0byBkaXNwbGF5IGluIHRoZSBuYXRpdmUgcHJvbXB0IGhlYWRlciBhc2tpbmcgdXNlciB3aGV0aGVyIHRvIHJlbWVtYmVyIHRoZWlyIGNob2ljZS5cbiAgICAgKiBEZWZhdWx0cyB0byBcIlJlbWVtYmVyIHlvdXIgY2hvaWNlP1wiIGlmIG5vdCBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgaGVhZGVyVGV4dD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiB0ZXh0IHRvIGRpc3BsYXkgaW4gdGhlIG5hdGl2ZSBwcm9tcHQgYm9keSBhc2tpbmcgdXNlciB3aGV0aGVyIHRvIHJlbWVtYmVyIHRoZWlyIGNob2ljZS5cbiAgICAgKiBEZWZhdWx0cyB0byBcIlVzZSB0aGUgc2FtZSBhcHAgZm9yIG5hdmlnYXRpbmcgbmV4dCB0aW1lP1wiIGlmIG5vdCBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgYm9keVRleHQ/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogdGV4dCB0byBkaXNwbGF5IGZvciB0aGUgWWVzIGJ1dHRvbi5cbiAgICAgKiBEZWZhdWx0cyB0byBcIlllc1wiIGlmIG5vdCBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgeWVzQnV0dG9uVGV4dD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiB0ZXh0IHRvIGRpc3BsYXkgZm9yIHRoZSBObyBidXR0b24uXG4gICAgICogRGVmYXVsdHMgdG8gXCJOb1wiIGlmIG5vdCBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgbm9CdXR0b25UZXh0Pzogc3RyaW5nO1xufVxuZXhwb3J0IGludGVyZmFjZSBSZW1lbWJlckNob2ljZU9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgdG8gcmVtZW1iZXIgdXNlciBjaG9pY2Ugb2YgYXBwIGZvciBuZXh0IHRpbWUsIGluc3RlYWQgb2YgYXNraW5nIGFnYWluIGZvciB1c2VyIGNob2ljZS5cbiAgICAgKiBgXCJwcm9tcHRcImAgLSBQcm9tcHQgdXNlciB0byBkZWNpZGUgd2hldGhlciB0byByZW1lbWJlciBjaG9pY2UuXG4gICAgICogIC0gRGVmYXVsdCB2YWx1ZSBpZiB1bnNwZWNpZmllZC5cbiAgICAgKiAgLSBJZiBgcHJvbXB0Rm5gIGlzIGRlZmluZWQsIHRoaXMgd2lsbCBiZSB1c2VkIGZvciB1c2VyIGNvbmZpcm1hdGlvbi5cbiAgICAgKiAgLSBPdGhlcndpc2UgKGJ5IGRlZmF1bHQpLCBhIG5hdGl2ZSBkaWFsb2cgd2lsbCBiZSBkaXNwbGF5ZWQgdG8gYXNrIHVzZXIuXG4gICAgICogYGZhbHNlYCAtIERvIG5vdCByZW1lbWJlciB1c2VyIGNob2ljZS5cbiAgICAgKiBgdHJ1ZWAgLSBSZW1lbWJlciB1c2VyIGNob2ljZS5cbiAgICAgKi9cbiAgICBlbmFibGVkPzogYm9vbGVhbiB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBhIGZ1bmN0aW9uIHdoaWNoIGFza3MgdGhlIHVzZXIgd2hldGhlciB0byByZW1lbWJlciB0aGVpciBjaG9pY2Ugb2YgYXBwLlxuICAgICAqIElmIHRoaXMgaXMgZGVmaW5lZCwgdGhlbiB0aGUgZGVmYXVsdCBkaWFsb2cgcHJvbXB0IHdpbGwgbm90IGJlIHNob3duLCBhbGxvd2luZyBmb3IgYSBjdXN0b20gVUkgZm9yIGFza2luZyB0aGUgdXNlci5cbiAgICAgKiBUaGlzIHdpbGwgYmUgcGFzc2VkIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIGludm9rZWQgd2l0aCBhIHNpbmdsZSBib29sZWFuIGFyZ3VtZW50IHdoaWNoIGluZGljYXRlcyB0aGUgdXNlcidzIGRlY2lzaW9uIHRvIHJlbWVtYmVyIHRoZWlyIGNob2ljZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwcm9tcHRGbj86IChjYWxsYmFjazogKHJlbWVtYmVyQ2hvaWNlOiBib29sZWFuKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIG9wdGlvbnMgcmVsYXRlZCB0byB0aGUgZGVmYXVsdCBkaWFsb2cgcHJvbXB0IHVzZWQgdG8gYXNrIHRoZSB1c2VyIHdoZXRoZXIgdG8gcmVtZW1iZXIgdGhlaXIgY2hvaWNlIG9mIGFwcC5cbiAgICAgKi9cbiAgICBwcm9tcHQ/OiBQcm9tcHRzT3B0aW9ucztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQXBwU2VsZWN0aW9uT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogdGV4dCB0byBkaXNwbGF5IGluIHRoZSBuYXRpdmUgcGlja2VyIHdoaWNoIGVuYWJsZXMgdXNlciB0byBzZWxlY3Qgd2hpY2ggbmF2aWdhdGlvbiBhcHAgdG8gbGF1bmNoLlxuICAgICAqIERlZmF1bHRzIHRvIFwiU2VsZWN0IGFwcCBmb3IgbmF2aWdhdGlvblwiIGlmIG5vdCBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgZGlhbG9nSGVhZGVyVGV4dD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiB0ZXh0IHRvIGRpc3BsYXkgZm9yIHRoZSBjYW5jZWwgYnV0dG9uIGluIHRoZSBuYXRpdmUgcGlja2VyIHdoaWNoIGVuYWJsZXMgdXNlciB0byBzZWxlY3Qgd2hpY2ggbmF2aWdhdGlvbiBhcHAgdG8gbGF1bmNoLlxuICAgICAqIERlZmF1bHRzIHRvIFwiQ2FuY2VsXCIgaWYgbm90IHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBjYW5jZWxCdXR0b25UZXh0Pzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYXBwcywgZGVmaW5lZCBhcyBgbGF1bmNobmF2aWdhdG9yLkFQUGAgY29uc3RhbnRzLCB3aGljaCBzaG91bGQgYmUgZGlzcGxheWVkIGluIHRoZSBwaWNrZXIgaWYgdGhlIGFwcCBpcyBhdmFpbGFibGUuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byByZXN0cmljdCB3aGljaCBhcHBzIGFyZSBkaXNwbGF5ZWQsIGV2ZW4gaWYgdGhleSBhcmUgaW5zdGFsbGVkLlxuICAgICAqIEJ5IGRlZmF1bHQsIGFsbCBhdmFpbGFibGUgYXBwcyB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICBsaXN0Pzogc3RyaW5nW107XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhbiBhcHAgaW4gdGhlIG5hdGl2ZSBwaWNrZXIuXG4gICAgICogQSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IGlzIHBhc3NlZCB3aGljaCBpcyB0aGUgYXBwIHdoYXQgd2FzIHNlbGVjdGVkIGRlZmluZWQgYXMgYSBgbGF1bmNobmF2aWdhdG9yLkFQUGAgY29uc3RhbnQuXG4gICAgICovXG4gICAgY2FsbGJhY2s/OiAoYXBwOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogKEFuZHJvaWQgb25seSkgbmF0aXZlIHBpY2tlciB0aGVtZS4gU3BlY2lmeSB1c2luZyBgYWN0aW9uc2hlZXQuQU5EUk9JRF9USEVNRVNgIGNvbnN0YW50cy5cbiAgICAgKiBEZWZhdWx0IGBhY3Rpb25zaGVldC5BTkRST0lEX1RIRU1FUy5USEVNRV9IT0xPX0xJR0hUYFxuICAgICAqL1xuICAgIGFuZHJvaWRUaGVtZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBvcHRpb25zIHJlbGF0ZWQgdG8gd2hldGhlciB0byByZW1lbWJlciB1c2VyIGNob2ljZSBvZiBhcHAgZm9yIG5leHQgdGltZSwgaW5zdGVhZCBvZiBhc2tpbmcgYWdhaW4gZm9yIHVzZXIgY2hvaWNlLlxuICAgICAqL1xuICAgIHJlbWVtYmVyQ2hvaWNlPzogUmVtZW1iZXJDaG9pY2VPcHRpb25zO1xufVxuZXhwb3J0IGludGVyZmFjZSBMYXVuY2hOYXZpZ2F0b3JPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBBIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZSBuYXZpZ2F0aW9uIGFwcCBpcyBzdWNjZXNzZnVsbHkgbGF1bmNoZWQuXG4gICAgICovXG4gICAgc3VjY2Vzc0NhbGxiYWNrPzogRnVuY3Rpb247XG4gICAgLyoqXG4gICAgICogQSBjYWxsYmFjayB0byBpbnZva2UgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgd2hpbGUgbGF1bmNoaW5nIHRoZSBhcHAuXG4gICAgICogQSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IGNvbnRhaW5pbmcgdGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBiZSBwYXNzZWQgaW4uXG4gICAgICovXG4gICAgZXJyb3JDYWxsYmFjaz86IChlcnJvcjogc3RyaW5nKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIG5hbWUgb2YgdGhlIG5hdmlnYXRpb24gYXBwIHRvIHVzZSBmb3IgZGlyZWN0aW9ucy5cbiAgICAgKiBTcGVjaWZ5IHVzaW5nIGxhdW5jaG5hdmlnYXRvci5BUFAgY29uc3RhbnRzLlxuICAgICAqIGUuZy4gYGxhdW5jaG5hdmlnYXRvci5BUFAuR09PR0xFX01BUFNgLlxuICAgICAqIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIFVzZXIgU2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGFwcD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBuaWNrbmFtZSB0byBkaXNwbGF5IGluIGFwcCBmb3IgZGVzdGluYXRpb24uIGUuZy4gXCJCb2IncyBIb3VzZVwiLlxuICAgICAqL1xuICAgIGRlc3RpbmF0aW9uTmFtZT86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTdGFydCBwb2ludCBvZiB0aGUgbmF2aWdhdGlvbi5cbiAgICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgY3VycmVudCBkZXZpY2UgbG9jYXRpb24gd2lsbCBiZSB1c2VkLlxuICAgICAqIEVpdGhlcjpcbiAgICAgKiAgLSBhIHtzdHJpbmd9IGNvbnRhaW5pbmcgdGhlIGFkZHJlc3MuIGUuZy4gXCJCdWNraW5naGFtIFBhbGFjZSwgTG9uZG9uXCJcbiAgICAgKiAgLSBhIHtzdHJpbmd9IGNvbnRhaW5pbmcgYSBsYXRpdHVkZS9sb25naXR1ZGUgY29vcmRpbmF0ZS4gZS5nLiBcIjUwLjEuIC00LjBcIlxuICAgICAqICAtIGFuIHthcnJheX0sIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSBsYXRpdHVkZSBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIGEgbG9uZ2l0dWRlLCBhcyBkZWNpbWFsIG51bWJlcnMuIGUuZy4gWzUwLjEsIC00LjBdXG4gICAgICovXG4gICAgc3RhcnQ/OiBzdHJpbmcgfCBudW1iZXJbXTtcbiAgICAvKipcbiAgICAgKiBuaWNrbmFtZSB0byBkaXNwbGF5IGluIGFwcCBmb3Igc3RhcnQgLiBlLmcuIFwiTXkgSG91c2VcIi5cbiAgICAgKi9cbiAgICBzdGFydE5hbWU/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0YXRpb24gbW9kZSBmb3IgbmF2aWdhdGlvbjogXCJkcml2aW5nXCIsIFwid2Fsa2luZ1wiIG9yIFwidHJhbnNpdFwiLiBEZWZhdWx0cyB0byBcImRyaXZpbmdcIiBpZiBub3Qgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIHRyYW5zcG9ydE1vZGU/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgZGVidWcgbG9nIG91dHB1dCB3aWxsIGJlIGdlbmVyYXRlZCBieSB0aGUgcGx1Z2luLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBlbmFibGVEZWJ1Zz86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogYSBrZXkvdmFsdWUgbWFwIG9mIGV4dHJhIGFwcC1zcGVjaWZpYyBwYXJhbWV0ZXJzLiBGb3IgZXhhbXBsZSwgdG8gdGVsbCBHb29nbGUgTWFwcyBvbiBBbmRyb2lkIHRvIGRpc3BsYXkgU2F0ZWxsaXRlIHZpZXcgaW4gXCJtYXBzXCIgbGF1bmNoIG1vZGU6IGB7XCJ0XCI6IFwia1wifWBcbiAgICAgKi9cbiAgICBleHRyYXM/OiBhbnk7XG4gICAgLyoqXG4gICAgICogKEFuZHJvaWQgb25seSkgbW9kZSBpbiB3aGljaCB0byBvcGVuIEdvb2dsZSBNYXBzIGFwcC5cbiAgICAgKiBgbGF1bmNobmF2aWdhdG9yLkxBVU5DSF9NT0RFLk1BUFNgIG9yIGBsYXVuY2huYXZpZ2F0b3IuTEFVTkNIX01PREUuVFVSTl9CWV9UVVJOYFxuICAgICAqIERlZmF1bHRzIHRvIGBsYXVuY2huYXZpZ2F0b3IuTEFVTkNIX01PREUuTUFQU2AgaWYgbm90IHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBsYXVuY2hNb2RlR29vZ2xlTWFwcz86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiAoaU9TIG9ubHkpIG1ldGhvZCB0byB1c2UgdG8gb3BlbiBBcHBsZSBNYXBzIGFwcC5cbiAgICAgKiBgbGF1bmNobmF2aWdhdG9yLkxBVU5DSF9NT0RFLlVSSV9TQ0hFTUVgIG9yIGBsYXVuY2huYXZpZ2F0b3IuTEFVTkNIX01PREUuTUFQS0lUYFxuICAgICAqIERlZmF1bHRzIHRvIGBsYXVuY2huYXZpZ2F0b3IuTEFVTkNIX01PREUuVVJJX1NDSEVNRWAgaWYgbm90IHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBsYXVuY2hNb2RlQXBwbGVNYXBzPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGFuZCBpbnB1dCBsb2NhdGlvbiB0eXBlKHMpIGRvZXNuJ3QgbWF0Y2ggdGhvc2UgcmVxdWlyZWQgYnkgdGhlIGFwcCwgdXNlIGdlb2NvZGluZyB0byBvYnRhaW4gdGhlIGFkZHJlc3MvY29vcmRzIGFzIHJlcXVpcmVkLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqL1xuICAgIGVuYWJsZUdlb2xvY2F0aW9uPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBvcHRpb25zIHJlbGF0ZWQgdG8gdGhlIGRlZmF1bHQgbmF0aXZlIGFjdGlvbnNoZWV0IHBpY2tlciB3aGljaCBlbmFibGVzIHVzZXIgdG8gc2VsZWN0IHdoaWNoIG5hdmlnYXRpb24gYXBwIHRvIGxhdW5jaCBpZiBgYXBwYCBpcyBub3Qgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIGFwcFNlbGVjdGlvbj86IEFwcFNlbGVjdGlvbk9wdGlvbnM7XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZXJDaG9pY2Uge1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGEgdXNlciBjaG9pY2UgZXhpc3RzIGZvciBhIHByZWZlcnJlZCBuYXZpZ2F0b3IgYXBwLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIHBhc3MgcmVzdWx0IHRvOiB3aWxsIHJlY2VpdmUgYSBib29sZWFuIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGV4aXN0czogKGNhbGxiYWNrOiAoZXhpc3RzOiBib29sZWFuKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCB1c2VyIGNob2ljZSBvZiBwcmVmZXJyZWQgbmF2aWdhdG9yIGFwcC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBwYXNzIHJlc3VsdCB0bzogd2lsbCByZWNlaXZlIGEgc3RyaW5nIGFyZ3VtZW50IGluZGljYXRpbmcgdGhlIGFwcCwgd2hpY2ggaXMgYSBjb25zdGFudCBpbiBgbGF1bmNobmF2aWdhdG9yLkFQUGAuXG4gICAgICovXG4gICAgZ2V0OiAoY2FsbGJhY2s6IChhcHA6IHN0cmluZykgPT4gdm9pZCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHVzZXIgY2hvaWNlIG9mIHByZWZlcnJlZCBuYXZpZ2F0b3IgYXBwLlxuICAgICAqIEBwYXJhbSBhcHAgLSBhcHAgdG8gc2V0IGFzIHByZWZlcnJlZCBjaG9pY2UgYXMgYSBjb25zdGFudCBpbiBgbGF1bmNobmF2aWdhdG9yLkFQUGAuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gY2FsbCBvbmNlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBzZXQ6IChhcHA6IHN0cmluZywgY2FsbGJhY2s6ICgpID0+IHZvaWQpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHVzZXIgY2hvaWNlIG9mIHByZWZlcnJlZCBuYXZpZ2F0b3IgYXBwLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgY2xlYXI6IChjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4gdm9pZDtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclByb21wdGVkIHtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB1c2VyIGhhcyBhbHJlYWR5IGJlZW4gcHJvbXB0ZWQgd2hldGhlciB0byByZW1lbWJlciB0aGVpciBjaG9pY2UgYSBwcmVmZXJyZWQgbmF2aWdhdG9yIGFwcC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBwYXNzIHJlc3VsdCB0bzogd2lsbCByZWNlaXZlIGEgYm9vbGVhbiBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBnZXQ6IChjYWxsYmFjazogKGV4aXN0czogYm9vbGVhbikgPT4gdm9pZCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBTZXRzIGZsYWcgaW5kaWNhdGluZyB1c2VyIGhhcyBhbHJlYWR5IGJlZW4gcHJvbXB0ZWQgd2hldGhlciB0byByZW1lbWJlciB0aGVpciBjaG9pY2UgYSBwcmVmZXJyZWQgbmF2aWdhdG9yIGFwcC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBjYWxsIG9uY2Ugb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIHNldDogKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENsZWFycyBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiB1c2VyIGhhcyBhbHJlYWR5IGJlZW4gcHJvbXB0ZWQgd2hldGhlciB0byByZW1lbWJlciB0aGVpciBjaG9pY2UgYSBwcmVmZXJyZWQgbmF2aWdhdG9yIGFwcC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBjYWxsIG9uY2Ugb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGNsZWFyOiAoY2FsbGJhY2s6ICgpID0+IHZvaWQpID0+IHZvaWQ7XG59XG5leHBvcnQgaW50ZXJmYWNlIEFwcFNlbGVjdGlvbiB7XG4gICAgdXNlckNob2ljZTogVXNlckNob2ljZTtcbiAgICB1c2VyUHJvbXB0ZWQ6IFVzZXJQcm9tcHRlZDtcbn1cbi8qKlxuICogQG5hbWUgTGF1bmNoIE5hdmlnYXRvclxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXF1aXJlcyBDb3Jkb3ZhIHBsdWdpbjogdWsuY28ud29ya2luZ2VkZ2UucGhvbmVnYXAucGx1Z2luLmxhdW5jaG5hdmlnYXRvci4gRm9yIG1vcmUgaW5mbywgcGxlYXNlIHNlZSB0aGUgW0xhdW5jaE5hdmlnYXRvciBwbHVnaW4gZG9jc10oaHR0cHM6Ly9naXRodWIuY29tL2RwYTk5Yy9waG9uZWdhcC1sYXVuY2gtbmF2aWdhdG9yKS5cbiAqXG4gKiBAdXNhZ2VcbiAqIFBsZWFzZSByZWZlciB0byB0aGUgcGx1Z2luJ3MgcmVwbyBmb3IgZGV0YWlsZWQgdXNhZ2UuIFRoaXMgZG9jcyBwYWdlIG9ubHkgZXhwbGFpbnMgdGhlIE5hdGl2ZSB3cmFwcGVyLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IExhdW5jaE5hdmlnYXRvciwgTGF1bmNoTmF2aWdhdG9yT3B0aW9ucyB9IGZyb20gJ0Bpb25pYy1uYXRpdmUvbGF1bmNoLW5hdmlnYXRvci9uZ3gnO1xuICpcbiAqIGNvbnN0cnVjdG9yKHByaXZhdGUgbGF1bmNoTmF2aWdhdG9yOiBMYXVuY2hOYXZpZ2F0b3IpIHsgfVxuICpcbiAqIC4uLlxuICpcbiAqIGxldCBvcHRpb25zOiBMYXVuY2hOYXZpZ2F0b3JPcHRpb25zID0ge1xuICogICBzdGFydDogJ0xvbmRvbiwgT04nLFxuICogICBhcHA6IExhdW5jaE5hdmlnYXRvci5BUFBTLlVCRVJcbiAqIH1cbiAqXG4gKiB0aGlzLmxhdW5jaE5hdmlnYXRvci5uYXZpZ2F0ZSgnVG9yb250bywgT04nLCBvcHRpb25zKVxuICogICAudGhlbihcbiAqICAgICBzdWNjZXNzID0+IGNvbnNvbGUubG9nKCdMYXVuY2hlZCBuYXZpZ2F0b3InKSxcbiAqICAgICBlcnJvciA9PiBjb25zb2xlLmxvZygnRXJyb3IgbGF1bmNoaW5nIG5hdmlnYXRvcicsIGVycm9yKVxuICogICApO1xuICogYGBgXG4gKiBAaW50ZXJmYWNlc1xuICogTGF1bmNoTmF2aWdhdG9yT3B0aW9uc1xuICogUHJvbXB0c09wdGlvbnNcbiAqIFJlbWVtYmVyQ2hvaWNlT3B0aW9uc1xuICogQXBwU2VsZWN0aW9uT3B0aW9uc1xuICogVXNlckNob2ljZVxuICogVXNlclByb21wdGVkXG4gKiBBcHBTZWxlY3Rpb25cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTGF1bmNoTmF2aWdhdG9yIGV4dGVuZHMgSW9uaWNOYXRpdmVQbHVnaW4ge1xuICAgIEFQUDogYW55O1xuICAgIFRSQU5TUE9SVF9NT0RFOiBhbnk7XG4gICAgYXBwU2VsZWN0aW9uOiBBcHBTZWxlY3Rpb247XG4gICAgLyoqXG4gICAgICogTGF1bmNoZXMgbmF2aWdhdG9yIGFwcFxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiB7c3RyaW5nfG51bWJlcltdfSBMb2NhdGlvbiBuYW1lIG9yIGNvb3JkaW5hdGVzIChhcyBzdHJpbmcgb3IgYXJyYXkpXG4gICAgICogQHBhcmFtIG9wdGlvbnMge0xhdW5jaE5hdmlnYXRvck9wdGlvbnN9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBuYXZpZ2F0ZShkZXN0aW5hdGlvbjogc3RyaW5nIHwgbnVtYmVyW10sIG9wdGlvbnM/OiBMYXVuY2hOYXZpZ2F0b3JPcHRpb25zKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGFwcCBpcyBpbnN0YWxsZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGUgY3VycmVudCBkZXZpY2UuXG4gICAgICogQHBhcmFtIGFwcCB7c3RyaW5nfVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgaXNBcHBBdmFpbGFibGUoYXBwOiBzdHJpbmcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3QgaW5kaWNhdGluZyB3aGljaCBhcHBzIGFyZSBpbnN0YWxsZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGUgY3VycmVudCBkZXZpY2UuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fVxuICAgICAqL1xuICAgIGF2YWlsYWJsZUFwcHMoKTogUHJvbWlzZTxzdHJpbmdbXT47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSBuYW1lIG9mIHRoZSBzcGVjaWZpZWQgYXBwLlxuICAgICAqIEBwYXJhbSBhcHAge3N0cmluZ31cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEFwcERpc3BsYXlOYW1lKGFwcDogc3RyaW5nKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgbGlzdCBvZiBzdXBwb3J0ZWQgYXBwcyBvbiBhIGdpdmVuIHBsYXRmb3JtLlxuICAgICAqIEBwYXJhbSBwbGF0Zm9ybSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRBcHBzRm9yUGxhdGZvcm0ocGxhdGZvcm06IHN0cmluZyk6IHN0cmluZ1tdO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBhbiBhcHAgb24gYSBnaXZlbiBwbGF0Zm9ybSBzdXBwb3J0cyBzcGVjaWZpY2F0aW9uIG9mIHRyYW5zcG9ydCBtb2RlLlxuICAgICAqIEBwYXJhbSBhcHAge3N0cmluZ30gc3BlY2lmaWVkIGFzIGEgc3RyaW5nLCB5b3UgY2FuIHVzZSBvbmUgb2YgdGhlIGNvbnN0YW50cywgZS5nIGBMYXVuY2hOYXZpZ2F0b3IuQVBQLkdPT0dMRV9NQVBTYFxuICAgICAqIEBwYXJhbSBwbGF0Zm9ybSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN1cHBvcnRzVHJhbnNwb3J0TW9kZShhcHA6IHN0cmluZywgcGxhdGZvcm06IHN0cmluZyk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc3BvcnQgbW9kZXMgc3VwcG9ydGVkIGJ5IGFuIGFwcCBvbiBhIGdpdmVuIHBsYXRmb3JtLlxuICAgICAqIEBwYXJhbSBhcHAge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gcGxhdGZvcm0ge3N0cmluZ31cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0VHJhbnNwb3J0TW9kZXMoYXBwOiBzdHJpbmcsIHBsYXRmb3JtOiBzdHJpbmcpOiBzdHJpbmdbXTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXBwIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHBsYXRmb3JtIHtzdHJpbmd9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3VwcG9ydHNEZXN0TmFtZShhcHA6IHN0cmluZywgcGxhdGZvcm06IHN0cmluZyk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGFuIGFwcCBvbiBhIGdpdmVuIHBsYXRmb3JtIHN1cHBvcnRzIHNwZWNpZmljYXRpb24gb2Ygc3RhcnQgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIGFwcCB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSBwbGF0Zm9ybSB7c3RyaW5nfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHN1cHBvcnRzU3RhcnQoYXBwOiBzdHJpbmcsIHBsYXRmb3JtOiBzdHJpbmcpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcHAge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gcGxhdGZvcm0ge3N0cmluZ31cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzdXBwb3J0c1N0YXJ0TmFtZShhcHA6IHN0cmluZywgcGxhdGZvcm06IHN0cmluZyk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGFuIGFwcCBvbiBhIGdpdmVuIHBsYXRmb3JtIHN1cHBvcnRzIHNwZWNpZmljYXRpb24gb2YgbGF1bmNoIG1vZGUuXG4gICAgICogTm90ZSB0aGF0IGN1cnJlbnRseSBvbmx5IEdvb2dsZSBNYXBzIG9uIEFuZHJvaWQgZG9lcy5cbiAgICAgKiBAcGFyYW0gYXBwIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHBsYXRmb3JtIHtzdHJpbmd9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgc3VwcG9ydHNMYXVuY2hNb2RlKGFwcDogc3RyaW5nLCBwbGF0Zm9ybTogc3RyaW5nKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb24ge3N0cmluZyB8IG51bWJlcltdfVxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtMYXVuY2hOYXZpZ2F0b3JPcHRpb25zfVxuICAgICAqL1xuICAgIHVzZXJTZWxlY3QoZGVzdGluYXRpb246IHN0cmluZyB8IG51bWJlcltdLCBvcHRpb25zOiBMYXVuY2hOYXZpZ2F0b3JPcHRpb25zKTogdm9pZDtcbn1cbiJdfQ==