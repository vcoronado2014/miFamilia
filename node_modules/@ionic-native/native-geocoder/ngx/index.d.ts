import { IonicNativePlugin } from '@ionic-native/core';
/**
 * @name Native Geocoder
 * @description
 * Cordova plugin for native forward and reverse geocoding
 *
 * @usage
 * ```typescript
 * import { NativeGeocoder, NativeGeocoderResult, NativeGeocoderOptions } from '@ionic-native/native-geocoder/ngx';
 *
 * constructor(private nativeGeocoder: NativeGeocoder) { }
 *
 * ...
 *
 * let options: NativeGeocoderOptions = {
 *     useLocale: true,
 *     maxResults: 5
 * };
 *
 * this.nativeGeocoder.reverseGeocode(52.5072095, 13.1452818, options)
 *   .then((result: NativeGeocoderResult[]) => console.log(JSON.stringify(result[0])))
 *   .catch((error: any) => console.log(error));
 *
 * this.nativeGeocoder.forwardGeocode('Berlin', options)
 *   .then((result: NativeGeocoderResult[]) => console.log('The coordinates are latitude=' + result[0].latitude + ' and longitude=' + result[0].longitude))
 *   .catch((error: any) => console.log(error));
 * ```
 * @interfaces
 * NativeGeocoderResult
 * NativeGeocoderOptions
 */
import * as ɵngcc0 from '@angular/core';
export declare class NativeGeocoder extends IonicNativePlugin {
    /**
     * Reverse geocode a given latitude and longitude to find location address
     * @param latitude {number} The latitude
     * @param longitude {number} The longitude
     * @param options {NativeGeocoderOptions} The options
     * @return {Promise<NativeGeocoderResult[]>}
     */
    reverseGeocode(latitude: number, longitude: number, options?: NativeGeocoderOptions): Promise<NativeGeocoderResult[]>;
    /**
     * Forward geocode a given address to find coordinates
     * @param addressString {string} The address to be geocoded
     * @param options {NativeGeocoderOptions} The options
     * @return {Promise<NativeGeocoderResult[]>}
     */
    forwardGeocode(addressString: string, options?: NativeGeocoderOptions): Promise<NativeGeocoderResult[]>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NativeGeocoder, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NativeGeocoder>;
}
/**
 * Encapsulates format information about a geocoding result.
 * more Info:
 *  - https://developer.apple.com/documentation/corelocation/clplacemark
 *  - https://developer.android.com/reference/android/location/Address.html
 */
export interface NativeGeocoderResult {
    /**
     * The latitude.
     */
    latitude: string;
    /**
     * The longitude.
     */
    longitude: string;
    /**
     * The country code.
     */
    countryCode: string;
    /**
     * The country name.
     */
    countryName: string;
    /**
     * The postal code.
     */
    postalCode: string;
    /**
     * The administrativeArea.
     */
    administrativeArea: string;
    /**
     * The subAdministrativeArea.
     */
    subAdministrativeArea: string;
    /**
     * The locality.
     */
    locality: string;
    /**
     * The subLocality.
     */
    subLocality: string;
    /**
     * The thoroughfare.
     */
    thoroughfare: string;
    /**
     * The subThoroughfare.
     */
    subThoroughfare: string;
    /**
     * The areasOfInterest
     */
    areasOfInterest: string[];
}
/**
 * Options for reverse and forward geocoding.
 */
export interface NativeGeocoderOptions {
    /**
     * The locale to use when returning the address information.
     * If set to 'false' the locale will always be 'en_US'.
     * Default is 'true'
     */
    useLocale: boolean;
    /**
     * The default locale to use when returning the address information.
     * e.g.: 'fa-IR' or 'de_DE'.
     */
    defaultLocale?: string;
    /**
     * The maximum number of result to return (max is 5).
     * Default is 1
     */
    maxResults: number;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW9uaWNOYXRpdmVQbHVnaW4gfSBmcm9tICdAaW9uaWMtbmF0aXZlL2NvcmUnO1xuLyoqXG4gKiBAbmFtZSBOYXRpdmUgR2VvY29kZXJcbiAqIEBkZXNjcmlwdGlvblxuICogQ29yZG92YSBwbHVnaW4gZm9yIG5hdGl2ZSBmb3J3YXJkIGFuZCByZXZlcnNlIGdlb2NvZGluZ1xuICpcbiAqIEB1c2FnZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgTmF0aXZlR2VvY29kZXIsIE5hdGl2ZUdlb2NvZGVyUmVzdWx0LCBOYXRpdmVHZW9jb2Rlck9wdGlvbnMgfSBmcm9tICdAaW9uaWMtbmF0aXZlL25hdGl2ZS1nZW9jb2Rlci9uZ3gnO1xuICpcbiAqIGNvbnN0cnVjdG9yKHByaXZhdGUgbmF0aXZlR2VvY29kZXI6IE5hdGl2ZUdlb2NvZGVyKSB7IH1cbiAqXG4gKiAuLi5cbiAqXG4gKiBsZXQgb3B0aW9uczogTmF0aXZlR2VvY29kZXJPcHRpb25zID0ge1xuICogICAgIHVzZUxvY2FsZTogdHJ1ZSxcbiAqICAgICBtYXhSZXN1bHRzOiA1XG4gKiB9O1xuICpcbiAqIHRoaXMubmF0aXZlR2VvY29kZXIucmV2ZXJzZUdlb2NvZGUoNTIuNTA3MjA5NSwgMTMuMTQ1MjgxOCwgb3B0aW9ucylcbiAqICAgLnRoZW4oKHJlc3VsdDogTmF0aXZlR2VvY29kZXJSZXN1bHRbXSkgPT4gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkocmVzdWx0WzBdKSkpXG4gKiAgIC5jYXRjaCgoZXJyb3I6IGFueSkgPT4gY29uc29sZS5sb2coZXJyb3IpKTtcbiAqXG4gKiB0aGlzLm5hdGl2ZUdlb2NvZGVyLmZvcndhcmRHZW9jb2RlKCdCZXJsaW4nLCBvcHRpb25zKVxuICogICAudGhlbigocmVzdWx0OiBOYXRpdmVHZW9jb2RlclJlc3VsdFtdKSA9PiBjb25zb2xlLmxvZygnVGhlIGNvb3JkaW5hdGVzIGFyZSBsYXRpdHVkZT0nICsgcmVzdWx0WzBdLmxhdGl0dWRlICsgJyBhbmQgbG9uZ2l0dWRlPScgKyByZXN1bHRbMF0ubG9uZ2l0dWRlKSlcbiAqICAgLmNhdGNoKChlcnJvcjogYW55KSA9PiBjb25zb2xlLmxvZyhlcnJvcikpO1xuICogYGBgXG4gKiBAaW50ZXJmYWNlc1xuICogTmF0aXZlR2VvY29kZXJSZXN1bHRcbiAqIE5hdGl2ZUdlb2NvZGVyT3B0aW9uc1xuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYXRpdmVHZW9jb2RlciBleHRlbmRzIElvbmljTmF0aXZlUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBSZXZlcnNlIGdlb2NvZGUgYSBnaXZlbiBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIHRvIGZpbmQgbG9jYXRpb24gYWRkcmVzc1xuICAgICAqIEBwYXJhbSBsYXRpdHVkZSB7bnVtYmVyfSBUaGUgbGF0aXR1ZGVcbiAgICAgKiBAcGFyYW0gbG9uZ2l0dWRlIHtudW1iZXJ9IFRoZSBsb25naXR1ZGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7TmF0aXZlR2VvY29kZXJPcHRpb25zfSBUaGUgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8TmF0aXZlR2VvY29kZXJSZXN1bHRbXT59XG4gICAgICovXG4gICAgcmV2ZXJzZUdlb2NvZGUobGF0aXR1ZGU6IG51bWJlciwgbG9uZ2l0dWRlOiBudW1iZXIsIG9wdGlvbnM/OiBOYXRpdmVHZW9jb2Rlck9wdGlvbnMpOiBQcm9taXNlPE5hdGl2ZUdlb2NvZGVyUmVzdWx0W10+O1xuICAgIC8qKlxuICAgICAqIEZvcndhcmQgZ2VvY29kZSBhIGdpdmVuIGFkZHJlc3MgdG8gZmluZCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSBhZGRyZXNzU3RyaW5nIHtzdHJpbmd9IFRoZSBhZGRyZXNzIHRvIGJlIGdlb2NvZGVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMge05hdGl2ZUdlb2NvZGVyT3B0aW9uc30gVGhlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPE5hdGl2ZUdlb2NvZGVyUmVzdWx0W10+fVxuICAgICAqL1xuICAgIGZvcndhcmRHZW9jb2RlKGFkZHJlc3NTdHJpbmc6IHN0cmluZywgb3B0aW9ucz86IE5hdGl2ZUdlb2NvZGVyT3B0aW9ucyk6IFByb21pc2U8TmF0aXZlR2VvY29kZXJSZXN1bHRbXT47XG59XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBmb3JtYXQgaW5mb3JtYXRpb24gYWJvdXQgYSBnZW9jb2RpbmcgcmVzdWx0LlxuICogbW9yZSBJbmZvOlxuICogIC0gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2RvY3VtZW50YXRpb24vY29yZWxvY2F0aW9uL2NscGxhY2VtYXJrXG4gKiAgLSBodHRwczovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9yZWZlcmVuY2UvYW5kcm9pZC9sb2NhdGlvbi9BZGRyZXNzLmh0bWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYXRpdmVHZW9jb2RlclJlc3VsdCB7XG4gICAgLyoqXG4gICAgICogVGhlIGxhdGl0dWRlLlxuICAgICAqL1xuICAgIGxhdGl0dWRlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGxvbmdpdHVkZS5cbiAgICAgKi9cbiAgICBsb25naXR1ZGU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgY291bnRyeSBjb2RlLlxuICAgICAqL1xuICAgIGNvdW50cnlDb2RlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGNvdW50cnkgbmFtZS5cbiAgICAgKi9cbiAgICBjb3VudHJ5TmFtZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3N0YWwgY29kZS5cbiAgICAgKi9cbiAgICBwb3N0YWxDb2RlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGFkbWluaXN0cmF0aXZlQXJlYS5cbiAgICAgKi9cbiAgICBhZG1pbmlzdHJhdGl2ZUFyZWE6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgc3ViQWRtaW5pc3RyYXRpdmVBcmVhLlxuICAgICAqL1xuICAgIHN1YkFkbWluaXN0cmF0aXZlQXJlYTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbGl0eS5cbiAgICAgKi9cbiAgICBsb2NhbGl0eTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBzdWJMb2NhbGl0eS5cbiAgICAgKi9cbiAgICBzdWJMb2NhbGl0eTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSB0aG9yb3VnaGZhcmUuXG4gICAgICovXG4gICAgdGhvcm91Z2hmYXJlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIHN1YlRob3JvdWdoZmFyZS5cbiAgICAgKi9cbiAgICBzdWJUaG9yb3VnaGZhcmU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgYXJlYXNPZkludGVyZXN0XG4gICAgICovXG4gICAgYXJlYXNPZkludGVyZXN0OiBzdHJpbmdbXTtcbn1cbi8qKlxuICogT3B0aW9ucyBmb3IgcmV2ZXJzZSBhbmQgZm9yd2FyZCBnZW9jb2RpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF0aXZlR2VvY29kZXJPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWxlIHRvIHVzZSB3aGVuIHJldHVybmluZyB0aGUgYWRkcmVzcyBpbmZvcm1hdGlvbi5cbiAgICAgKiBJZiBzZXQgdG8gJ2ZhbHNlJyB0aGUgbG9jYWxlIHdpbGwgYWx3YXlzIGJlICdlbl9VUycuXG4gICAgICogRGVmYXVsdCBpcyAndHJ1ZSdcbiAgICAgKi9cbiAgICB1c2VMb2NhbGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgbG9jYWxlIHRvIHVzZSB3aGVuIHJldHVybmluZyB0aGUgYWRkcmVzcyBpbmZvcm1hdGlvbi5cbiAgICAgKiBlLmcuOiAnZmEtSVInIG9yICdkZV9ERScuXG4gICAgICovXG4gICAgZGVmYXVsdExvY2FsZT86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzdWx0IHRvIHJldHVybiAobWF4IGlzIDUpLlxuICAgICAqIERlZmF1bHQgaXMgMVxuICAgICAqL1xuICAgIG1heFJlc3VsdHM6IG51bWJlcjtcbn1cbiJdfQ==